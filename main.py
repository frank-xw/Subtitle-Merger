#!/usr/bin/env python3
"""Merge two SRT subtitles into a single ASS file with distinct styles."""

from __future__ import annotations

import argparse
import re
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional, Tuple


@dataclass
class SrtEntry:
    index: int
    start_ms: int
    end_ms: int
    text: str


SRT_TIME_RE = re.compile(r"^(\d{2}):(\d{2}):(\d{2}),(\d{3})$")
TAG_RE = re.compile(r"<[^>]+>")


def parse_srt_time(value: str) -> int:
    match = SRT_TIME_RE.match(value.strip())
    if not match:
        raise ValueError(f"Invalid SRT time: {value}")
    hh, mm, ss, ms = map(int, match.groups())
    return (((hh * 60) + mm) * 60 + ss) * 1000 + ms


def ms_to_ass_time(ms: int) -> str:
    if ms < 0:
        ms = 0
    total_seconds, millis = divmod(ms, 1000)
    cs = millis // 10
    minutes, seconds = divmod(total_seconds, 60)
    hours, minutes = divmod(minutes, 60)
    return f"{hours}:{minutes:02d}:{seconds:02d}.{cs:02d}"


def ms_to_srt_time(ms: int) -> str:
    if ms < 0:
        ms = 0
    total_seconds, millis = divmod(ms, 1000)
    hours, remainder = divmod(total_seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    return f"{hours:02d}:{minutes:02d}:{seconds:02d},{millis:03d}"


def normalize_text(text: str) -> str:
    text = text.replace("\r", "")
    text = TAG_RE.sub("", text)
    text = text.strip()
    if not text:
        return ""
    lines = [line.strip() for line in text.split("\n") if line.strip()]
    return "\\N".join(lines)


def parse_srt(path: Path) -> List[SrtEntry]:
    content = path.read_text(encoding="utf-8-sig")
    blocks = re.split(r"\n{2,}", content.strip())
    entries: List[SrtEntry] = []
    for block in blocks:
        lines = [line.strip() for line in block.split("\n") if line.strip()]
        if len(lines) < 2:
            continue
        try:
            index = int(lines[0])
        except ValueError:
            index = len(entries) + 1
        time_line = lines[1]
        if "-->" not in time_line:
            continue
        start_str, end_str = [part.strip() for part in time_line.split("-->")]
        start_ms = parse_srt_time(start_str)
        end_ms = parse_srt_time(end_str)
        text = normalize_text("\n".join(lines[2:]))
        entries.append(SrtEntry(index=index, start_ms=start_ms, end_ms=end_ms, text=text))
    return entries


def find_secondary_for_main(
    main_entries: List[SrtEntry],
    secondary_entries: List[SrtEntry],
    tolerance_ms: int = 500,
) -> List[Tuple[SrtEntry, Optional[SrtEntry]]]:
    paired: List[Tuple[SrtEntry, Optional[SrtEntry]]] = []
    j = 0
    for main in main_entries:
        while j < len(secondary_entries) and secondary_entries[j].end_ms < main.start_ms - tolerance_ms:
            j += 1
        best: Optional[SrtEntry] = None
        best_overlap = -1
        k = j
        while k < len(secondary_entries):
            candidate = secondary_entries[k]
            if candidate.start_ms > main.end_ms + tolerance_ms:
                break
            overlap_start = max(main.start_ms, candidate.start_ms)
            overlap_end = min(main.end_ms, candidate.end_ms)
            overlap = overlap_end - overlap_start
            if overlap >= 0 and overlap > best_overlap:
                best_overlap = overlap
                best = candidate
            k += 1
        if best is None and j < len(secondary_entries):
            candidate = secondary_entries[j]
            gap_start = abs(candidate.start_ms - main.start_ms)
            gap_end = abs(candidate.end_ms - main.end_ms)
            if min(gap_start, gap_end) <= tolerance_ms:
                best = candidate
        paired.append((main, best))
    return paired


def build_ass(
    pairs: List[Tuple[SrtEntry, Optional[SrtEntry]]],
    main_style: str,
    secondary_style: str,
    main_margin_v: int,
    secondary_margin_v: int,
    gap_size: int,
) -> str:
    header = """[Script Info]
; Script generated by Subtitle-Merger
ScriptType: v4.00+
Collisions: Normal
PlayResX: 1920
PlayResY: 1080
ScaledBorderAndShadow: yes
WrapStyle: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
"""

    events_header = """[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""

    lines = [header]
    lines.append(main_style)
    lines.append(secondary_style)
    lines.append("")
    lines.append(events_header)

    for main, secondary in pairs:
        if not main.text:
            continue
        start = ms_to_ass_time(main.start_ms)
        end = ms_to_ass_time(main.end_ms)
        if secondary and secondary.text:
            gap = max(1, gap_size)
            text = (
                f"{main.text}\\N{{\\fs{gap}}}\\N{{\\rSecondary}}{secondary.text}"
            )
        else:
            text = main.text
        lines.append(
            f"Dialogue: 0,{start},{end},Main,,0,0,{main_margin_v},,{text}"
        )

    return "\n".join(lines).strip() + "\n"


def build_styles(
    main_size: int,
    secondary_size: int,
    secondary_color: str,
    main_margin_v: int,
    secondary_margin_v: int,
) -> Tuple[str, str]:
    # Colors in ASS are AABBGGRR (hex). Default to light gray if invalid.
    color = secondary_color.strip().upper()
    if not re.fullmatch(r"&H[0-9A-F]{8}", color):
        color = "&H00A0A0A0"
    main_style = (
        f"Style: Main,Arial,{main_size},&H00FFFFFF,&H00FFFFFF,&H00000000,&H64000000,"
        f"0,0,0,0,100,100,0,0,1,2,1,2,30,30,{main_margin_v},1"
    )
    secondary_style = (
        f"Style: Secondary,PingFang SC,{secondary_size},{color},&H00FFFFFF,&H00202020,&H40000000,"
        f"0,0,0,0,100,100,0,0,1,2.5,0.8,2,30,30,{secondary_margin_v},1"
    )
    return main_style, secondary_style


def infer_paths(
    main_path: Optional[str],
    secondary_path: Optional[str],
    main_suffix: str,
    secondary_suffix: str,
    cwd: Path,
) -> Tuple[Path, Path]:
    if main_path:
        main = Path(main_path)
        if secondary_path:
            return main, Path(secondary_path)
        # try to infer secondary by replacing suffix
        stem = main.stem
        if stem.endswith(main_suffix):
            alt_stem = stem[: -len(main_suffix)] + secondary_suffix
            candidate = main.with_name(alt_stem + main.suffix)
            if candidate.exists():
                return main, candidate
        # fallback: search in same dir
        matches = list(main.parent.glob(f"*{secondary_suffix}.srt"))
        if len(matches) == 1:
            return main, matches[0]
        raise FileNotFoundError("Secondary subtitle not found. Provide --secondary.")

    # no main path: infer from cwd
    main_matches = list(cwd.glob(f"*{main_suffix}.srt"))
    secondary_matches = list(cwd.glob(f"*{secondary_suffix}.srt"))
    if len(main_matches) != 1 or len(secondary_matches) != 1:
        raise FileNotFoundError(
            "Could not infer subtitles. Provide --main and --secondary explicitly."
        )
    return main_matches[0], secondary_matches[0]


def build_output_path(main_path: Path, main_suffix: str) -> Path:
    stem = main_path.stem
    if stem.endswith(main_suffix):
        base = stem[: -len(main_suffix)]
    else:
        base = stem
    return main_path.with_name(f"{base}.EN_CN.ass")


def build_output_path_srt(main_path: Path, main_suffix: str) -> Path:
    stem = main_path.stem
    if stem.endswith(main_suffix):
        base = stem[: -len(main_suffix)]
    else:
        base = stem
    return main_path.with_name(f"{base}.EN_CN.srt")


def run(
    main_path: Optional[str],
    secondary_path: Optional[str],
    output_path: Optional[str],
    main_suffix: str,
    secondary_suffix: str,
    main_size: int,
    secondary_size: int,
    secondary_color: str,
    gap_size: int,
    output_format: str,
) -> Path:
    cwd = Path.cwd()
    main_file, secondary_file = infer_paths(
        main_path, secondary_path, main_suffix, secondary_suffix, cwd
    )

    main_entries = parse_srt(main_file)
    secondary_entries = parse_srt(secondary_file)
    pairs = find_secondary_for_main(main_entries, secondary_entries)

    if output_format == "srt":
        out_text = build_srt(pairs)
        out_path = (
            Path(output_path)
            if output_path
            else build_output_path_srt(main_file, main_suffix)
        )
    else:
        main_style, secondary_style = build_styles(
            main_size=main_size,
            secondary_size=secondary_size,
            secondary_color=secondary_color,
            main_margin_v=0,
            secondary_margin_v=0,
        )
        out_text = build_ass(
            pairs,
            main_style,
            secondary_style,
            main_margin_v=0,
            secondary_margin_v=0,
            gap_size=gap_size,
        )
        out_path = (
            Path(output_path)
            if output_path
            else build_output_path(main_file, main_suffix)
        )

    out_path.write_text(out_text, encoding="utf-8")
    return out_path


def build_arg_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Merge two SRT subtitles into one ASS file with distinct styles.",
    )
    parser.add_argument("main", nargs="?", help="Main SRT file (default: *-EN.srt)")
    parser.add_argument(
        "secondary", nargs="?", help="Secondary SRT file (default: *-CN.srt)"
    )
    parser.add_argument("-o", "--output", help="Output ASS file path")
    parser.add_argument("--main-suffix", default="-EN", help="Main suffix in filename")
    parser.add_argument(
        "--secondary-suffix", default="-CN", help="Secondary suffix in filename"
    )
    parser.add_argument("--main-size", type=int, default=52, help="Main font size")
    parser.add_argument(
        "--secondary-size", type=int, default=46, help="Secondary font size"
    )
    parser.add_argument(
        "--secondary-color",
        default="&H40999999",
        help="Secondary color in ASS hex (AABBGGRR).",
    )
    parser.add_argument(
        "--gap-size",
        type=int,
        default=30,
        help="Gap size between main and secondary (font size units).",
    )
    parser.add_argument(
        "--format",
        choices=["ass", "srt"],
        default="srt",
        help="Output format (ass or srt).",
    )
    return parser


def build_srt(
    pairs: List[Tuple[SrtEntry, Optional[SrtEntry]]],
) -> str:
    lines: List[str] = []
    idx = 1
    for main, secondary in pairs:
        if not main.text:
            continue
        start = ms_to_srt_time(main.start_ms)
        end = ms_to_srt_time(main.end_ms)
        main_text = main.text.replace("\\N", "\n")
        if secondary and secondary.text:
            secondary_text = secondary.text.replace("\\N", "\n")
            text = f"{main_text}\n{secondary_text}"
        else:
            text = main_text
        lines.append(str(idx))
        lines.append(f"{start} --> {end}")
        lines.append(text)
        lines.append("")
        idx += 1
    return "\n".join(lines).strip() + "\n"


def main() -> None:
    parser = build_arg_parser()
    args = parser.parse_args()
    out_path = run(
        main_path=args.main,
        secondary_path=args.secondary,
        output_path=args.output,
        main_suffix=args.main_suffix,
        secondary_suffix=args.secondary_suffix,
        main_size=args.main_size,
        secondary_size=args.secondary_size,
        secondary_color=args.secondary_color,
        gap_size=args.gap_size,
        output_format=args.format,
    )
    print(f"Wrote: {out_path}")


if __name__ == "__main__":
    main()
